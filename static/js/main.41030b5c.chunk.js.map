{"version":3,"sources":["serviceWorker.ts","utils/escapeText.ts","utils/translationCache.ts","utils/translate.ts","utils/index.ts","components/MainTop.tsx","components/MainScreen.tsx","index.tsx"],"names":["Boolean","window","location","hostname","match","escapeText","text","encodeURIComponent","cache","translate","lang","setResult","clearText","clearLang","cached","checkCache","console","log","requestString","process","fetch","then","res","ok","Error","status","json","data","response","entry","setCache","catch","error","TranslateUtil","MainTop","source","target","handleSource","handleTarget","className","id","onChange","value","MainScreen","props","state","input","output","detected","bind","handleChange","handleSubmit","this","setState","event","eTarget","preventDefault","prom","Promise","rows","placeholder","type","onClick","React","Component","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.41030b5c.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.',\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","function escapeText(text: string): string {\n  // what, there's nothing better?\n  return encodeURIComponent(text);\n}\n\nexport default escapeText;\n","import * as T from './types';\n\n// cache holds only while the session lasts\nlet cache: T.Dictionary<T.cacheEntry> = {};\n\nexport function checkCache(text: string): T.cacheEntry | undefined {\n  return cache[text];\n}\n\nexport function setCache(\n  text: string,\n  lang: string,\n  response: T.APIJson,\n): void {\n  const entry: T.cacheEntry = [lang, response];\n  cache[text] = entry;\n  // console.log('Cached');\n  return;\n}\n","import * as T from './types';\nimport escapeText from './escapeText';\nimport { checkCache, setCache } from './translationCache';\n\nconst APIKEY = process.env.REACT_APP_YAN_API_KEY;\nconst APIURL = 'https://translate.yandex.net/api/v1.5/tr.json/translate';\n\n// no default here, as would result in [top].default.default if the top is required instead of import\nexport function translate(\n  text: string,\n  lang: string,\n  setResult?: (data: T.APIJson) => void,\n): Promise<T.APIJson | void> | T.APIJson | undefined {\n  // on wrong lang input: will be reflected in the response status code\n  // me too lazy to build the entire available language list,\n  // or even to check using the API list of supported languages\n\n  // escape special characters\n  const clearText: string = escapeText(text);\n  // because language might be input by a user too\n  const clearLang: string = escapeText(lang);\n\n  // use result caching\n  const cached: T.cacheEntry | undefined = checkCache(clearText);\n  if (cached) {\n    // in particular: if the (cleared) text matches, but lang does not,\n    // the call will be made, and the cache entry will be rewritten\n    if (cached[0] === clearLang) {\n      // exact matching not really the best, as, e.g., 'en' and 'ru-en' should usually give the same result;\n      console.log('Cached result:');\n      console.log(cached[1]);\n      // if logging was the only thing to do, might be better to do it right in the checkCache()\n      // but it is not, as it is assumed translate function will have more use for the result\n      return cached[1];\n    }\n  }\n\n  // options=1 asks to include detected language in the API response\n  const requestString = `${APIURL}?key=${APIKEY}&text=${clearText}&lang=${clearLang}&options=1`;\n\n  return fetch(requestString)\n    .then((res) => {\n      if (!res.ok) {\n        // res type is not specified here;\n        // is there point in constructing Response just for that?\n        // don't think so\n\n        // On wrong network response\n        throw new Error('Error: Network response not ok');\n      }\n      if (res.status === 200) {\n        // the API states that 200 is the code for all successful operations\n        return res.json();\n      } else {\n        // On working response with a wrong status code\n        throw new Error(`Wrong status code of API response: ${res.status}`);\n      }\n    })\n    .then((data: T.APIJson) => {\n      // what shall we do with corect data?\n      setCache(clearText, clearLang, data);\n      console.log(data);\n      if (setResult) {\n        setResult(data);\n      }\n      return data;\n    })\n    .catch((error) => console.log(`Error on fetching translation: ${error}`));\n\n  // return;\n}\n","import * as TranslateUtil from './translate';\n\nexport default TranslateUtil;\n","import React from 'react';\n// import PropTypes from 'prop-types';\n\ninterface mainTopProps {\n  source: string;\n  target: string;\n  handleSource: (event: React.SyntheticEvent<HTMLSelectElement>) => void;\n  handleTarget: (event: React.SyntheticEvent<HTMLSelectElement>) => void;\n}\n\nconst MainTop: React.FunctionComponent<mainTopProps> = ({\n  source,\n  target,\n  handleSource,\n  handleTarget,\n}) => {\n  return (\n    <div className=\"lang-div\">\n      <p className=\"top-text\">Source language:</p>\n      <p>{source}</p>\n      <select id=\"source\" onChange={handleSource}>\n        <option value=\"??\">Auto-detect</option>\n        <option value=\"en\">English</option>\n        <option value=\"de\">German</option>\n        <option value=\"ru\">Russian</option>\n        <option value=\"fr\">French</option>\n        <option value=\"sp\">Spanish</option>\n        <option value=\"it\">Italian</option>\n      </select>\n      <p className=\"top-text\">Target language:</p>\n      <p>{target}</p>\n      <select id=\"target\" onChange={handleTarget}>\n        <option value=\"en\">English</option>\n        <option value=\"de\">German</option>\n        <option value=\"ru\">Russian</option>\n        <option value=\"fr\">French</option>\n        <option value=\"sp\">Spanish</option>\n        <option value=\"it\">Italian</option>\n      </select>\n    </div>\n  );\n};\n\nexport default MainTop;\n","import React from 'react';\n// import PropTypes from 'prop-types';\n\nimport * as TranslateUtil from './../utils/index';\nimport * as T from './../utils/types';\nimport MainTop from './MainTop';\n\ninterface mainScreenState {\n  input: string;\n  output: string;\n  target: string;\n  source: string;\n  detected: string;\n}\n\ninterface mainScreenProps {}\n\nclass MainScreen extends React.Component<mainScreenProps, mainScreenState> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      input: '',\n      output: '',\n      target: 'en',\n      source: '??',\n      detected: '',\n    };\n\n    this.setResult = this.setResult.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.handleSource = this.handleSource.bind(this);\n    this.handleTarget = this.handleTarget.bind(this);\n  }\n\n  setResult(data: T.APIJson) {\n    this.setState({ output: data.text[0], detected: data.detected.lang });\n  }\n\n  handleSource(event: React.SyntheticEvent<HTMLSelectElement>) {\n    let eTarget = event.target as HTMLSelectElement;\n    this.setState({ source: eTarget.value });\n  }\n\n  handleTarget(event: React.SyntheticEvent<HTMLSelectElement>) {\n    let eTarget = event.target as HTMLSelectElement;\n    this.setState({ target: eTarget.value });\n  }\n\n  handleChange(event: { target: { value: string } }) {\n    this.setState({ input: event.target.value });\n  }\n\n  handleSubmit(event: { preventDefault: () => void }) {\n    event.preventDefault();\n    const { input, source, target } = this.state;\n    // console.log(TranslateUtil.default.translate);\n    if (input === '') {\n      return;\n    }\n    let lang: string;\n    if (source === '??') {\n      lang = target;\n    } else {\n      lang = `${source}-${target}`;\n    }\n    const prom = TranslateUtil.default.translate(input, lang, this.setResult);\n    // stupid version of return type check\n    if (prom && !(prom instanceof Promise)) {\n      this.setResult(prom);\n      return;\n    }\n  }\n\n  render() {\n    const { target, source, input, output, detected } = this.state;\n    return (\n      <div className=\"upper-div\">\n        <MainTop\n          target={target}\n          source={source}\n          handleTarget={this.handleTarget}\n          handleSource={this.handleSource}\n        />\n        <div className=\"text-row\">\n          <textarea\n            rows={20}\n            className=\"text-field input-field\"\n            onChange={this.handleChange}\n            value={input}\n            placeholder=\"Input text to be translated\"\n          />\n          <textarea\n            rows={20}\n            className=\"text-field output-field\"\n            value={output}\n            placeholder=\"Translation\"\n          />\n        </div>\n        <button type=\"submit\" onClick={this.handleSubmit}>\n          Translate!\n        </button>\n        <p>{detected !== '' ? `Detected language: ${detected}` : ''}</p>\n      </div>\n    );\n  }\n}\n\nexport default MainScreen;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport './styles/mainScreenStyles.css';\nimport './styles/mainTopStyles.css';\n\nimport MainScreen from './components/MainScreen';\n\nReactDOM.render(\n  <React.StrictMode>\n    <MainScreen />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}